# 운영체제
## 프로세스에 대한 연산

### 프로세스 생성
- 부모 프로세스: 새로운 프로세스를 생성하는 프로세스
- 자식 프로세스: 새로운 프로세스
- 자식 프로세스는 또 새로운 프로세스를 생성할 수 있으며, 그 결과 '프로세스 트리' 형성 (`pstree`)
<br><br>
- 운영체제는 프로세스 식별자(pid)로 프로세스 구분
- Linux의 언제나 pid가 1인 systemd 프로세스 (UNIX 시스템은 init 프로세스) <br> 
: 모든 사용자 프로세스의 루트 부모 프로세스 역할 수행<br>
: 시스템이 부트될 때 생성되는 첫 번째 사용자 프로세스
- logind 프로세스: 시스템에 직접 로그인하는 클라이언트 관리
- sshd 프로세스: ssh 사용해 시스템에 접속하는 클라이언트 관리

부모 프로세스는 자식 프로세스에 자원을 제공하거나 초기화 데이터(입력)을 전달할 수 있다

**프로세스가 새로운 프로세스 생성할 때, 두 프로세스를 실행시키는 두 가지 방법**
1. 부모는 자식과 병행하게 실행 계속함
2. 부모는 일부 또는 모든 자식이 실행 종료할 때까지 기다림

**자식 프로세스의 주소 공간 측면 두 가지 경우**
1. 자식 프로세스는 부모 프로세스의 복사본 (동일한 프로그램과 데이터)
- 새로운 프로세스는 `fork()` 시스템 콜로 생성되며, 부모 프로세스의 주소 공간의 복사본으로 구성
- 부모와 자식 프로세스는 fork() 후의 명령어에서부터 실행 계속함
- 차이점은 fork()의 return 값: 자식 프로세스는 항상 0을 return, 부모 프로세스는 자식 프로세스의 PID (0이 아닌)를 return 받음<br>
-> 자식 프로세스가 자신이 자식임을 알 수 있게 하고, 부모는 자식 프로세스를 성공적으로 생성했음을 알기 위해
- 부모와 자식은 같은 코드를 실행하는 병행 실행 프로세스 
- 각 프로세스는 모든 데이터에 대해 자신만의 복사본이 있다

```C
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork(); // 새로운 프로세스 생성

    if (pid > 0) {
        // 부모 프로세스 (fork()가 자식의 PID를 반환)
        printf("부모 프로세스 실행: 자식 PID = %d\n", pid);
    } else if (pid == 0) {
        // 자식 프로세스 (fork()가 0을 반환)
        printf("자식 프로세스 실행\n");
    } else {
        // fork() 실패
        perror("fork 실패");
    }

    return 0;
}
```

2. 자식 프로세스가 자신에게 load될 새로운 프로그램 가지고 있다
- fork() 시스템 콜 후 두 프로세스 중 한 프로세스가 `exec()` 시스템 콜 사용해 자신의 메모리 공간을 새로운 프로그램으로 교체
-> exec(): exec() 시스템 콜을 포함하는 원래의 프로그램의 메모리 이미지를 파괴하고, 이진 파일을 메모리로 load한 후 프로그램 실행 
- 그 후 각자의 길을 가며, 부모는 자식보다 먼저 종료하지 않고 자식이 실행하는 동안 기다리기 위해 `wait()` 시스템 콜을 한다
- 자식 프로세스가 끝나면 부모 프로세스는 wait()으로 부터 재개해 `exit()` 시스템 콜을 사용해 끝낸다

### 프로세스 종료

**프로세스 종료 발생하는 경우**
1. 자신(프로세스)이 exit() 시스템 콜로 운영체제에서 자신의 삭제를 요청: 모든 자원 할당이 해제되고 종료
2. 시스템 콜을 통해 다른 프로세스의 종료 유발
: 종료될 프로세스의 부모만이 호출 가능
: 자식의 pid를 알아야 한다

몇몇 시스템에서는 부모 프로세스 종료 후 자식 프로세스가 존재할 수 없기 때문에, 프로세스가 종료되면 그에서 비롯된 모든 자식 프로세스들도 종료되어야 한다: 연쇄식 종료 (운영체제가 시행)

`exit(1)`: exit()시스템 콜은 종료 상태를 나타내는 인자 전달받음

`pid = wait(&status)`: wait()은 부모가 자식의 종료 상태를 얻을 수 있게 인자를 전달받고, 어느 자식이 종료되었는지 구별할 수 있도록 종료된 자식 프로세스 식별자가 return된다
-> 자식 프로세스가 종료되면 운영 체제는 자식 프로세스의 종료 상태를 부모 프로세스가 읽어가도록 함

**좀비 프로세스**<br>
(프로세스의 종료 상태가 저장되는 프로세스 테이블이 있음)
- 자식 프로세스가 종료되었지만, 부모가 종료 상태를 회수하지 않아 (부모가 아직 wait()을 호출하지 않음) 프로세스 테이블에 남아 있는 상태
- 프로세스 종료시 모든 프로세스는 아주 짧은 시간 동안 좀비 상태가 됨. 부모가 wait()을 호출하면 좀비 프로세스의 식별자와 프로세스 테이블의 해당 항목이 운영체제에 반환됨
- 좀비 프로세스는 자원을 소모하지는 않지만, 운영 체제의 프로세스 테이블 항목을 차지하므로 자원이 낭비됨

**고아 프로세스**
- 부모가 wait()을 호출하는 대신 자식보다 먼저 종료했을 때, 그 상황에 부딪힌 자식 프로세스 (자식은 실행 중인데 부모가 먼저 종료)
- 운영체제에 의해 관리되지만 의도한 흐름이 아님<br>
: UNIX는 고아 프로세스의 새로운 부모 프로세스로 init 프로세스를 지정<br>
: init 프로세스는 주기적으로 wait()을 호출해 고아 프로세스의 종료 상태 수집하고 프로세스 식별자와 프로세스 테이블 항목 반환
(Linux는 systemd)

**Android 프로세스 계층**<br>
모바일 운영체제는 제한된 시스템 자원으로, 프로세스의 중요도 계층을 식별

(중요도 순서. 1이 제일 중요)
1. forground process: 사용자가 현재 상호 작용중인 프로그램으로, 화면에 보이는 프로세스
2. visible process: 직접 볼 수 없지만 forground process가 참조하는 활동
3. service process: background process와 유사하지만 사용자가 인지할 수 있는 활동을 수행하는 프로세스 (예: 음악 스트리밍)
4. background process: 활동 수행하고 있지만 사용자가 인식하지 못하는 프로세스 
5. empty process: 프로그램과 관련된 활성 구성요소가 없는 프로세스