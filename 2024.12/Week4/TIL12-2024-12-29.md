# 운영체제
## 시스템 서비스
컴퓨터의 논리적 계층 구조: (최하위) 하드웨어 -> 운영체제 -> 시스템 서비스 -> 응용 프로그램

- 시스템 서비스(=시스템 유틸리티): 프로그램 개발과 실행을 위해 편리한 환경 제공

### 시스템 서비스 분류
**파일 관리**<br>
파일과 디렉터리 조작

**상태 정보**<br>
시스템의 단순 정보 혹은 로깅 및 디버깅 정보 제공

**파일 변경**<br>
저장된 파일 내용 변경하기 위해 문장 편집기 사용 가능

**프로그래밍언어 지원**<br>
일반적인 프로그래밍 언어들에 대한 컴파일러, 어셈블러, 디버거 및 해석기 제공

**프로그램 적재와 수행**<br>
프로그램이 수행되려면 메모리에 적재되어야 한다<br>

**통신**<br>
프로세스, 사용자, 다른 컴퓨터 시스템들 사이에서 가상 접속 이루는 기법 제공<br>
-> 사용자가 다른 사용자 화면으로 메시지 전송, 웹페이지 읽기, 전자 우편 메시지 보내기, 원격 로그인, 파일 전송 등을 가능하게 한다

**백그라운드 서비스**<br>
모든 시스템은 부트할 때 특정 시스템 프로그램을 시작시킬 수 있는 방법이 있다. 프로세스 중 일부는 자신들이 할 일을 완수하고 종료하는 반면, 일부는 시스템이 정지될 때까지 계속 실행되는 프로세스도 있다.<br>

- 항상 실행되는 시스템 프로그램 프로세스 = deamon

운영체제는 시스템 프로그램과 함께 일반 연산을 수행하는 데 유용한 프로그램(웹브라우저, 워드프로세서, 데이터베이스 시스템, 컴파일러 등)도 제공

## 링커와 로더
CPU에서 실행하려면 프로그램을 메모리로 가져와 프로세스 형태로 배치해야 한다

프로그램은 디스크에 이진 실행파일 (.out 또는 .exe)로 존재<br>
- 소스 파일은 임의의 물리 메모리 위치에 적재되도록 설계된 오브젝트 파일로 컴파일되며, 이 형식의 파일을 '재배치 가능한 오브젝트 파일'이라 한다
- 링커는 재배치 가능한 오브젝트 파일을 하나의 이진 실행 파일로 결합한다. 링킹 단계에서 다른 오브젝트 파일 또는 라이브러리가 포함될 수 있다
- 로더는 이진 실행 파일을 메모리에 적재하며, CPU 코어에서 실행할 수 있는 상태가 된다

링크 및 로더 활동은 재배치로, 프로그램에 최종 주소 할당하고 프로그램 코드와 데이터를 해당 주소와 일치하게 조정해 프로그램이 실행될 때 코드가 라이브러리 함수를 호출하고 변수에 접근할 수 있게 한다

로더 실행하려면 명령어 라인에 실행 파일 이름 (ex. `./main`) 입력하면 된다

**명령어 라인에 실행 파일 이름 입력시 (GUI: 아이콘 더블클릭시 유사)**<br>
(정적링크 방식을 가정: 라이브러리가 실행 파일에 통합되어 있어서 `exec()`는 별도로 라이브러리를 찾거나 로드하지 않는다)
1. `fork()` 시스템 콜로 프로그램 실행 위한 새 프로세스 생성
2. `exec()` 시스템 콜로 로더 호출
3. `exec()`에 실행 파일 이름 전달
4. 로더는 새로 생성된 프로세스의 주소 공간 사용해 지정된 프로그램을 메모리에 적재

+동적링크의 경우, 관련 함수나 변수가 실제로 호출될 때 라이브러리가 공유메모리에 적재된다

![alt text](../../image/image-6.png)
이미지 출처: https://howudong.tistory.com/234

**동적 링크**
- 실행 파일에서 사용되지 않을 수 있는 라이브러리를 링크하고 로드하지 않아도 된다
- 프로그램 실행 시간에 필요할 경우 적재됨
- 링커는 프로그램이 적재될 때 동적으로 링크되고 적재될 수 있도록 재배치 정보를 삽입
- 여러 프로세스가 동적으로 링크된 라이브러리 공유할 수 있어, 메모리 사용이 절약됨

### 동적 링크의 메모리 동작 방식
**프로세스 메모리 공간**<br>
A 프로세스는 독립적인 메모리 공간을 가지며, 해당 메모리에는 프로그램 코드와 데이터가 올라감

**라이브러리 메모리 공간**<br>
공유 메모리 영역에 로드. 라이브러리가 메모리에 이미 적재되어 있으면 이를 다른 프로세스와 공유

**링크 과정**<br>
A 프로세스가 실행되면, 운영체제는 A 프로세스의 주소 공간에서 해당 라이브러리가 필요한 위치에 재배치 정보를 삽입하여 동적 링크를 설정<br>
이때 라이브러리 자체는 운영체제의 공유 메모리에 위치하고, A 프로세스는 해당 라이브러리의 함수나 데이터를 참조할 때 공유 메모리의 주소를 사용

### 정적 링크 작동 방식
라이브러리 코드를 컴파일 시간에 실행 파일에 포함시킨다<br>
즉, 필요한 라이브러리 함수나 데이터를 실행 파일 내부에 복사해서 붙여 넣는 방식 <br>
실행 시 필요한 라이브러리가 별도로 로드되지 않는다. 즉 실행 파일 하나만 있으면 라이브러리까지 포함된 상태로 동작

```
[개념]
- 컴파일: 고급언어로 만든 소스 코드를 바이너리 코드로 변환하는 과정. 오브젝트 파일이 생성된다 (컴퓨터가 이해하는 기계어로 변환시키는 작업) -> 이런 작업 해주는 프로그램 = 컴파일러
- 빌드: 소스코드 파일을 실행 가능한 소프트웨어 산출몰로 변환시키는 과정 (빌드의 단계에 컴파일이 포함)
- 오브젝트 파일: 컴파일 혹은 어셈블러 프로그램 통해 변환된 파일

- 링크: 여러개로 분리된 소스파일들을 컴파일한 결과물에서 실행가능한 파일을 만들기 위해 필요한 부분을 찾아서 연결해주는 작업
ex) A소스파일에서 B소스파일의 메서드 호출해서 사용한 경우, A와 B를 각각 컴파일하면 A가 B에 존재하는 함수를 찾지못해서 호출할 수 없다. 따라서 A와 B를 연결해주는 작업이 필요
- 정적링크: 컴파일된 소스 파일과 라이브러리를 컴파일 시점에 결합해 하나의 실행 가능한 파일을 생성하는 과정
- 동적링크: 프로그램 실행 시 필요한 라이브러리를 외부에서 동적으로 로드하여 사용하는 방식. 실행 파일은 라이브러리를 참조만 하고, 라이브러리 파일은 별도로 존재하며, 프로그램 실행 중에 연결된다

- 어셈블러: 어셈블리어를 기계어 형태의 오브젝트 코드로 바꿔주는 프로그램 

- 인터프리터: 고급 언어로 작성된 원시코드 명령어를 한 줄씩 읽어들여 실행하는 프로그램. 컴파일 과정이 필요하지 않으므로, 원시코드를 기계어로 번역하는 컴파일러와 대비된다
```

## 응용 프로그램이 운영체제마다 다른 이유
한 운영체제에서 컴파일된 응용 프로그램은 다른 운영체제에서 실행할 수 없다<br>
각 운영체제는 고유한 시스템 콜 집합을 제공한다. 

**동일 응용 프로그램이 여러 운영체제에서 실행되게 하는 세 가지 방법**
1. 응용 프로그램을 인터프리터 언어로 작성하기<br>
-> 인터프리터 언어는 소스 코드를 직접 실행하지 않고, 인터프리터 프로그램이 소스 코드를 읽고 해당 코드를 각 운영체제에서 실행 가능한 명령으로 변환. 운영체제 세부사항에 의존x<br>
-> 단점: 기계어로 구성된 프로그램에 비해 성능 떨어지고, 인터프리터는 각 운영체제 기능의 일부만 제공해서 기능 제한될 수 있음
2. 응용 프로그램을 포함하는 가상 머신을 가진 언어로 작성하기 <br>
-> ex) Java
3. 개발자는 컴파일러가 운영체제 고유의 이진 파일을 생성하는 표준 언어나 API 사용해 개발

즉, 특정 CPU 유형의 특정 운영체제에서 인터프리터, RTE, 이진 실행 파일을 작성하고 컴파일하지 않으면 응용 프로그램이 실행되지 않는다

## 운영체제 설계 및 구현
**기법과 정책**<br>
기법으로부터 정책을 분리해야한다
- 기법: 어떤 일을 어떻게 할 것인가 결정하는 것
- 정책: 무엇을 할 것인가를 결정하는 것

ex) 타이머 구조는 CPU 보호를 보장하는 기법이지만, 특정 사용자를 위해 타이머를 얼마나 오래 설정할지 결정하는건 정책적 결정

정책은 자주 변경될 수 있음

**구현**<br>
- 초기 운영체제는 어셈블리 언어로 작성
- 현재 대부분은 C, C++같은 고급언어로 작성되며 극히 일부 시스템이 어셈블리 언어로 작성 
- 운영체제의 소량 코드만이 고성능이 중요<br>
: 인터럽트 핸들러, 입출력 관리자, 메모리 관리자, CPU 스케줄러