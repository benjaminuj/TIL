# 운영체제
## System calls
시스템 콜: 운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스 제공

### 예제
**시스템 콜이 어떻게 사용되나?**<br>

예시) 한 파일로부터 데이터 읽어 다른 파일로 복사하는 프로그램 작성한다고 가정<br>

프로그램은 먼저 입력 파일과 출력 파일 이름을 입력 받아야 한다.<br>
방법 1. 명령어로 전달받기 `cp in.txt out.txt`<br>
방법 2. 프로그램이 사용자에게 이름 요청 (대화형 시스템)<br> 
-> 많은 I/O 시스템 콜 필요 

두 파일 이름이 얻어지면, 프로그램은 입력 파일을 오픈하고 출력 파일을 생성한 후 오픈한다.<br>
-> 이 연산도 시스템 콜을 필요로 하며, 각 시스템 콜에서 오류 발생시 처리되어야 한다. (오류 처리도 시스템 콜)<br>
ex) 입력 파일 이름을 갖는 파일이 존재하지 않거나 파일에 대한 접근 금지 발견 -> 에러 메시지 출력 (시스템 콜), 비정상적 종료(시스템 콜)<br>
ex) 출력 파일 이름과 동일한 이름 가진 파일이 이미 존재 -> 프로그램 중단 (시스템 콜), 기존 파일 삭제(시스템 콜), 새로운 파일 생성(시스템 콜)<br>

두 파일이 준비되면, 입력 파일로부터 읽어 (시스템 콜) 출력 파일에 기록(시스템 콜)하는 루프에 들어간다.<br>

전체 파일이 복사된 후, 프로그램은 두 파일을 닫고 (2개의 시스템 콜), 메시지를 기록하고(시스템 콜), 정상적으로 종료한다(시스템 콜)

### 응용 프로그램 인터페이스 (Application Programming Interface)
간단한 기능도 초당 수천 개의 시스템 콜 수행<br>
응용 개발자들은 응용 프로그래밍 인터페이스(API) 에 따라 프로그램 설계

**API**
- 각 함수에 전달되어야 할 매개변수와 반환 값을 포함해 응용 프로그래머가 사용 가능한 함수의 집합 명시
- 종류: Windows API, POSIX API, Java API
- 프로그래머는 운영체제가 제공하는 코드의 라이브러리 통해 API 활용
- API 구성 함수들은 응용 프로그래머를 대신해 실제 시스템 콜 호출<br>
-> 왜 응용 프로그래머들은 실제 시스템 콜을 호출하는 것보다 API 따라 프로그래밍 하나?<br>
응용 프로그래머는 자신의 프로그램이 같은 API를 지원하는 어느 시스템에서건 컴파일되고 실행되는 것을 기대하기 때문

**RTE(실행시간 환경)**<br>
- 시스템 콜 처리에 중요한 요소
- 운영체제가 제공하는 시스템 콜에 대한 연결고리 역할을 하는 '시스템 콜 인터페이스' 제공

**시스템 콜 인터페이스**
- API 함수의 호출을 가로채, 필요한 운영체제 시스템 콜 호출하고 시스템 콜의 상태와 반환 값을 돌려준다
- 시스템 콜에 할당된 번호에 따라 색인되는 테이블 가지고있다

시스템 콜은 컴퓨터에 따라 다른 방법으로 발생해서, 운영체제따라 필요한 정보가 다르다. <br><br>
**운영체제에 매개변수 전달하는 방법**<br>
방법1. 매개변수를 레지스터 내에 전달<br>
-> 레지스터보다 많은 매개변수 있을 때 문제<br>
방법2. 매개변수는 메모리 내 블록이나 테이블에 저장되고, 블록 주소가 레지스터 내 매개변수로 전달<br>
방법3. stack에 push<br>
-> 방법2, 3은 매개변수 개수나 길이 제한 x

### 시스템 콜 유형
프로세스 제어, 파일 조작, 장치 조작, 정보 유지보수, 통신, 보호

**1. 프로세스 제어**
- 실행 중인 프로그램은 수행을 정상적으로 끝내거나(`end()`) 비정상적으로 멈출 수 있다(`abort()`)

프로그램 비정상적 중지될 경우 메모리가 덤프되고 오류 메시지 생성된다. 덤프는 로그 파일이나 디스크에 기록되고 문제 원인 결정을 위해 디버거에 의해 검사된다<br>
+디버거: 버그를 찾고 수정하는 데 도움주는 시스템 프로그램

정상이거나 비정상 상황에서 운영체제는 명령 인터프리터로 제어를 전달하고, 명령 인터프리터는 다음 명령을 수행한다.<br> 
이때, 오류 등급을 사용해 다음 행동을 자동으로 결정할 수도 있고, 대화식 시스템에서는 사용자가 오류에 응답하는 명령 내릴 것을 가정할 수도 있다.

- 한 프로그램을 실행하고 있는 프로세스가 다른 프로그램을 적재(`load()`)하고 실행(`execute()`)할 수 있다

적재된 프로그램이 종료되었을 때 어디로 제어를 되돌려주느냐?<br> 
-> '기존 프로그램이 유실 or 보관 or 새로운 프로그램과 병행하게 실행'하는 문제와 관련<br> 
제어를 어떻게하느냐에 따라 새로운 프로세스를 생성한다(`create_process()`)

새로운 잡이나 프로세스를 생성하면 우리가 제어해야한다. 속성들을 결정하고 재설정할 수 있다<br>
-> `get_process_attributes()`, `set_process_attributes()`

새로운 잡이나 프로세스를 종료할 수 있다 `terminate_process()`<br>
새로운 프로세스 생성한 후 실행이 끝나기를 기다려야할 때, 일정 시간만큼 기다리거나(`wait_time()`), 특정 이벤트가 일어날 때까지 기다릴 수 있다(`wait_event()`). 이 경우 프로세스들은 그 이벤트가 일어나면 신호를 보내야 한다(`signal_event()`)

프로세스가 공유하는 데이터의 일관성을 위해 운영체제는 프로세스가 공유 데이터를 잠글 수 있는 시스템 콜 제공. `acquire_lock()` `release_lock()`

- 단일 태스킹 시스템: 한 순간에 하나의 프로그램만 메모리에 존재 가능
- 다중 태스킹 시스템: 한 순간에 다수 프로세스 메모리에 존재 가능

**다중 태스킹 시스템**<br>
새로운 프로세스 시작 위해 셸은 `fork()` 시스템 콜 실행 -> 선택된 프로그램이 `exec()` 시스템 콜 통해 메모리에 적재됨 -> 프로그램 수행<br>

명령이 내려진 방법에 따라 셸은 프로세스 종료를 기다리거나 프로세스를 백그라운드에서 수행<br>
백그라운드에서 프로세스 수행할 경우 셸은 바로 다른 명령이 입력되기를 기다리고, 셸이 키보드로부터 직접 입력받는 자원을 사용하고 있기 때문에 백그라운드 프로세스는 직접 입력받을 수 없다. 백그라운드 프로세스의 입출력은 파일, 또는 GUI 인터페이스 통해 행해진다. 반면 사용자는 셸에게 요청을 자유롭게 할 수 있다

프로세스 끝나면 `exit()` 시스템 콜 수행하고, 호출한 프로세스에게 상태 코드 0이나 오류 코드를 돌려준다. 그리고 이 코드는 셸 또는 다른 프로그램들이 이용 할 수 있다

**2. 파일 관리**<br>
파일을 생성(`create()`)하고 삭제(`delete()`)할 수 있다<br>
파일이 생성되면 열고(`open()`), 읽기(`read()`), 쓰기(`write()`) 위치변경(`reposition()`), 파일 닫기(`close()`) 할 수 있다

파일 속성 값을 결정할 수 있다
-> 설정 (`set_file_attribute()`), 조회(`get_file_attribute()`)

파일 이동(`move()`)과 복사(`copy()`) 시스템 콜도 제공된다

**3. 장치관리**<br>
프로세스는 작업 중 추가 자원을 필요로 할 수 있는데, 추가 자원은 주 기억장치, 디스크 드라이브, 파일에의 접근 등이 될 수 있다<br>
운영체제에 제어되는 자원들은 장치로 간주될 수 있다<br> 물리장치 (ex.디스크 드라이브)나 추상장치(ex. 파일)가 있다

시스템은 독점적인 장치 사용을 보장받기 위해 장치를 요청(`request()`)한다. 할당 받으면 장치를 읽고(`read()`), 쓰고(`write()`)할 수 있다. 장치 사용이 끝나면 방출(`release()`)한다.

입출력 장치와 파일 간 유사성이 많기 때문에, 운영체제는 이 둘을 '파일-장치 구조'로 결합했고, 시스템 콜이 파일과 장치에 대해 사용된다. 입출력 장치들은 파일 이름, 디렉터리 배치 또는 파일 속성으로 식별된다

**4. 정보 유지 관리**<br>
많은 시스템 콜은 단순히 사용자 프로그램과 운영체제 간 정보 전달을 위해 존재한다<br>
ex. 현재 시간(`time()`)과 날짜(`date()`), 운영체제나 메모리에 관한 정보 등

또 다른 시스템 콜은 프로그램 디버깅에 도움된다. <br> 메모리를 덤프(`dump()`)할 수 있고, 한 명령어 실행(single step)이라고 하는 CPU 모드를 제공하기도 한다. 이 모드에서는 명령어 실행 후에 트랩이 CPU에 의해 실행된다. 트랩은 디버거에 의해 포착된다

운영체제는 프로그램의 time profile 제공한다. 이는 그 프로그램이 특정 위치에서 수행한 시간의 양을 나타낸다.<br>
또한 운영체제는 현재 실행중인 프로세스에 관한 정보를 가지고 있고, 이 정보에 접근하기 위한 시스템 콜이 있다.

**5. 통신**
- 통신 모델 종류: 메시지 전달, 공유 메모리

- 메시지 전달 모델 <br> 
: 통신하는 두 프로세스가 정보 교환을 위해 메시지를 주고받는다<br> 
: 통신 전에 연결이 열려야 하며, 상대 통신자가 동일 CPU에 있는 프로세스이든지 연결된 다른 컴퓨터에 있는 프로세스이든지 그 이름을 알고 있어야 한다<br> 
: 수신 프로세스는 통신이 일어날 수 있도록 `accept_connection()` 호출에 자신의 허가를 제공한다<br> 
: daemon은 연결을 위해 대기 (`wait_for_connection()`)호출을 수행하고 연결이 이루어질 때 깨어난다 <br> 
: 클라이언트와 서버는 `read_message()`, `write_message()`시스템 콜로 메시지 교환한다<br> 
: `close_connection()`으로 통신 종료

네트워크의 각 컴퓨터는 호스트 이름을 가지며, 각 프로세스도 프로세스 이름을 가지고 있다. <br> 
프로세스 이름은 운영체제에 의해 식별자로 변환되고, 식별자는 운영체제가 프로세스를 가리키는 데 사용한다. <br> 
-> `get_hostid()`, `get_processid()`는 이런 변환을 수행한다

- 공유 메모리 모델<br> 
: 공유 영역에서 데이터를 읽고 씀으로써 정보를 교환 <br>
: 프로세스는 다른 프로세스가 소유한 메모리 영역에 대한 접근을 위해 `shared_memory_create()`와 `shared_memory_attach()` 시스템 콜 사용

운영체제가 프로세스 간의 간섭을 방지하고 안정적인 실행 환경을 제공하기 위해 프로세스별로 메모리 사용 영역을 구분하고, 정상적으로는 다른 프로세스의 메모리에 접근하는 것을 막는다.

**6. 보호**<br>
컴퓨터 시스템 자원에 대한 접근을 제어하기 위한 기법을 지원

- 허가 권한 설정 관련: `set_permission()`, `get_permission()`
- 특정 사용자가 지정된 자원에 접근 허가 혹은 불허: `allow_user()`, `deny_user()`