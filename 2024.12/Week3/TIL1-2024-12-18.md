# 운영체제

## 1.1 운영체제가 할 일
**컴퓨터 시스템 구성**<br>
하드웨어, 운영체제, 응용 프로그램, 사용자

- 하드웨어: CPU, I/O 장치, 메모리 -> 계산용 자원 제공
- 응용 프로그램: 사용자 계산 문제를 해결하기 위해 자원이 어떻게 사용될지 정의
- 운영체제: 응용 프로그램 간 하드웨어 사용을 제어하고 조정, 프로그램 작업 환경 제공

**컴퓨터 시스템 목표** <br>
프로그램 실행 및 사용자 문제를 쉽게 해결하기 <br>
-> 이를 위해 '하드웨어 + 응용 프로그램' 존재 <br>
-> 프로그램의 입출력 장치 제어 같은 공통 작업(자원 제어 및 할당)을 '운영체제' SW로 통합

- 커널: 컴퓨터에서 항상 실행되는 프로그램
- 시스템 프로그램: 운영체제와 관련
- 응용 프로그램: 시스템 작동과 관련x
- 미들웨어: 응용 프로그램 개발을 쉽게하고 기능 제공

운영체제 구성: 커널, 미들웨어, 시스템 프로그램

## 1.2 컴퓨터 시스템 구성
- CPU
- 장치 컨트롤러 

CPU와 여러 장치 컨트롤러는 공통버스(구성요소와 공유 메모리 간 액세스 제공)로 연결

**장치 컨트롤러**
- 로컬 버퍼 저장소와 레지스터 집합을 유지 관리
- 제어 장치와 로컬 버퍼 저장소 간 데이터 이동

**장치 드라이버**
- 각 장치 컨트롤러마다 존재
- 운영체제에 장치에 대한 인터페이스 제공

### 1.2.1 인터럽트
- CPU 조치가 필요한 이벤트에 대해 경고하는 것
- 하드웨어가 시스템 버스를 통해 CPU에 신호 보내서 인터럽트 발생
- 운영체제와 하드웨어 사이 상호 작용 방식 핵심

**예시) 입출력 수행 프로그램**
1. 장치 드라이버가 장치 컨트롤러의 레지스터에 값 적재
2. 장치 컨트롤러는 레지스터 내용 검사해 수행할 작업 결정
3. 장치 컨트롤러는 장치에서 로컬 버퍼로 데이터 전송 및 전송완료
4. 장치 컨트롤러는 장치 드라이버에게 작업이 완료됨을 알림
5. 장치 드라이버는 (읽기 요청일 경우) 데이터 또는 데이터 포인터 반환 후 운영체제 다른 부분에 제어 넘김

컨트롤러가 장치 드라이버에게 작업 완료 사실을 어떻게 알리나? 인터럽트를 통해!

1. CPU가 인터럽트 됨
2. CPU는 하던 일 중단하고 고정된 위치로 실행 옮긴다<br>
+고정된 위치: 인터럽트를 유발한 장치를 위한 서비스 루틴이 위치한 시작 주소를 가지고 있다.
3. 인터럽트 서비스 루틴 실행 및 완료
4. CPU는 연산 재개

**전달 관리 방법**
- 직선적 방법: 인터럽트 정보 조사하는 일반적 루틴 호출 -> 이후 인터럽트 핸들러 호출
- 간접적 방법: 인터럽트 루틴에 대한 포인터들의 테이블 이용 (직선적 방법보다 빠름)<br>
+테이블에는 여러 장치에 대한 인터럽트 서비스 루틴 주소가 있다<br>
+인터럽트 요청시, 인터럽트 벡터가 유발한 장치 번호로 색인된다

**인터럽트 구조**

인터럽트된 모든 정보를 저장해야 인터럽트 처리 후 복원 가능<br>
처리기의 상태 변경 필요할 경우, 인터럽트 루틴은 현재 상태 저장하고 복귀 전에 상태를 복원해야 함<br>
인터럽트를 서비스 한 후, 저장되어 있던 복귀 주소를 프로그램 카운터에 적재하고 중단되었던  연산 다시 수행

**인터럽트 메커니즘**

CPU 하드웨어에 '인터럽트 요청 라인'이라는 선 존재: 명령어 실행 완료시 CPU가 이 선 감지

1. 컨트롤러가 인터럽트 요청 라인에 신호 보내고, CPU가 이를 감지
2. 인터럽트 번호를 읽고, 이 번호를 인터럽트 벡터의 인덱스로 사용
3. 인터럽트 핸들러 루틴으로 점프
4. 인덱스와 관련된 주소에서 실행 시작

**인터럽트 처리기**
- 작업 중 변경될 상태 저장
- 인터럽트 원인 확인
- 처리 수행
- 상태 복원 수행

**장치 컨트롤러**
- 인터럽트 요청 라인에 신호 선언해 인터럽트 발생(raise)

**CPU**
- 인터럽트 포착(catch)
- 인터럽트를 핸들러로 dispatch

**핸들러**
- 장치를 서비스하여 인터럽트를 지운다(clear)

**CPU 및 인터럽트 컨트롤러 하드웨어**
- 중요 처리 중에는 인터럽트 처리를 연기
- 인터럽트의 우선순위 구분하고 적절 긴급도로 대응

**2개의 인터럽트 요청 라인 (CPU에 존재)**
- nonmaskable interrupt: 복구 불가능한 메모리 오류같은 이벤트 위해 예약
- maskable: 장치 컨트롤러가 서비스 요청 위해 사용

**벡터 방식 인터럽트 기법의 목적**<br>
서비스가 필요한 장치 결정을 위해 모든 인터럽트 소스를 검색할 필요 줄이는 것

**인터럽트 체인**<br>
실제 컴퓨터에는 인터럽트 벡터의 주소 개수보다 많은 장치가 있어, 이 문제 해결하는 방법.
- 인터럽트 벡터의 각 원소는 인터럽트 핸들러 리스트의 헤드 가리킨다
- 인터럽트 발생시 요청을 처리할 수 있는 핸들러가 발견될 때까지 상응하는 리스트의 핸들러가 하나씩 호출된다

**인터럽트 기법의 우선순위 레벨**<br>
CPU는 모든 인터럽트를 마스킹하지 않고도 우선순위가 낮은 인터럽트 처리 연기하거나 우선순위가 높은 인터럽트가 실행 선점할 수 있다.

**인터럽트**
- 비동기 이벤트 처리를 위해 사용
- 장치 컨트롤러 및 하드웨어 오류로 인해 인터럽트 발생
- 긴급 작업을 먼저 수행하기 위해 인터럽트 우선순위 시스템 사용
- 시간에 민감한 처리에 빈번하게 사용

### 1.2.2 저장장치 구조
컴퓨터는 프로그램을 메인 메모리(RAM. RAM은 휘발성)에서 가져온다.<br>
컴퓨터 전원을 켤 때 가장 먼저 실행되는 프로그램은 부트스트랩 프로그램이며 운영체제를 적재한다<br>

- 메모리: 바이트 배열을 제공
- 각 바이트는 자신의 주소를 가지고 있다. 
- 상호작용은 메모리 주소들에 대한 적재(load) 또는 저장(store)명령으로 이루어진다
- 적재: 메인 메모리로부터 CPU 내부의 레지스터로 한 바이트 또는 한 워드를 옮기는 것
- 저장: 레지스터의 내용을 메인 메모리로 옮기는 것
- CPU는 프로그램 카운터에 저장된 위치부터 실행하기 위해 메인 메모리에서 명령을 자동으로 적재한다

**폰 노이만 구조 시스템의 명령-실행 사이클**<br>
메모리로부터 명령을 인출해 명령 레지스터에 저장한다. 명령을 해독하고 실행한 후 결과가 메모리에 다시 저장된다.

**저장장치 표기**
- 워드: 컴퓨터 구조의 본연의 데이터 단위. 한 워드는 하나 이상의 바이트로 구성
- 컴퓨터는 한 바이트 단위가 아니라 본연의 워드 단위로 연산 실행

메인 메모리는 휘발성이고, 프로그램과 데이터를 영구히 저장하기 너무 작다.<br>
그러므로 컴퓨터 시스템은 대량의 데이터를 영구히 보존할 수 있는 보조저장장치를 제공한다.

**보조저장장치**
- 종류: 하드 디스크 드라이브(HDD), 비휘발성 메모리(NVM) 장치
- 메인 메모리보다 느리다

**3차 저장장치**
- 백업 사본을 저장 (특수 목적으로만 사용)
- 매우 느리고 충분히 큰 저장장치

메모리가 작고 빠를수록 CPU에 더 가깝다.

**1차 저장장치 (휘발성)**
- 종류: 레지스터, 캐시, 메인 메모리
- 용량: 레지스터 < 캐시 < 메인 메모리
- 속도: 레지스터 > 캐시 > 메인 메모리

**비휘발성 저장장치(NVS)**
- 유형: 기계적, 전기적
- 용량: 기계적 > 전기적
- 바이트당 비용: 기계적 < 전기적
- 속도: 기계적 < 전기적

### 1.2.3 입출력 구조
범용 버스를 통해 데이터 교환하는 여러 장치로 구성된 범용 컴퓨터 -> 대량 데이터 이동시 높은 오버헤드 유발 -> DMA로 해결

**직접 메모리 액세스(DMA)**
- 장치 컨트롤러는 CPU 개입 없이 메모리로부터 자신의 버퍼 장치로 또는 버퍼로부터 메모리로 데이터 블록 전체 전송
- 블록(바이트x) 전송 완료될 때마다 인터럽트 발생 
- 장치 컨트롤러가 전송 작업 수행하는 동안 CPU는 다른 작업 수행 가능
