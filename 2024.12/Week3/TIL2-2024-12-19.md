# 운영체제
## 1.3 컴퓨터 시스템 구조
사용된 범용 처리기의 수에 따라 분류

**컴퓨터 시스템 구성 요소 정의**
- CPU: 명령을 실행하는 하드웨어
- 프로세서: 하나 이상의 CPU를 포함하는 물리적 칩
- 코어: CPU의 기본 계산 단위
- 다중코어: 동일한 CPU에 여러 컴퓨팅 코어 포함
- multiprocessor: 여러 프로세서를 포함

### 1.3.1 단일 처리기 시스템 Single-Processor
단일 처리 코어를 가진 하나의 CPU를 포함하는 단일 프로세서

코어: 명령 실행하고 로컬로 데이터를 저장하기 위한 레지스터를 포함하는 구성요소<br>
코어를 가진 CPU는 명령어를 실행할 수 있다

### 1.3.2 다중 처리기 시스템 Multiprocessor
- 단일 시스템 내에 단일 코어 CPU가 있는 프로세서가 2개 이상
- 모든 프로세서는 메모리와 디스크 등의 자원을 공유
- 처리량 증가. 그러나 여러 프로세서 협력 오버헤드로 인해 N 프로세서의 속도 향상 비율은 N이 아니다
- 오버헤드 + 공유 자원에 대한 경합 -> 예상 이득 낮음
- 여러 개의 컴퓨팅 코어가 단일 칩에 있는 다중 코어 시스템도 다중 처리기에 포함<br>
칩 내 통신이 칩 간 통신보다 빨라, 다중 코어 시스템은 단일 코어를 가지는 여러 칩보다 효율적이고 적은 전력 사용
- 프로세서 간 통신: 공유 메모리를 통해

**SMP**<br>
- 각 처리기의 CPU에 자체 레지스터와 로컬 캐시가 있다
- 자체 CPU를 가진 여러 프로세서가 시스템 버스로 하나의 메인 메모리를 공유
- 장점: 많은 프로세스 동시 실행 가능<br>
그러나 CPU 독립적 -> 하나는 유휴 상태, 하나는 과부하로 비효율적일 수 있다

다중 처리기 시스템에 CPU를 너무 많이 추가 -> 시스템 버스에 대한 경합이 병목 현상이 되어 성능 저하 발생 -> NUMA로 해결

**NUMA(non-uniform memory access)**
- 각 CPU에 로컬 버스를 통해 액세스 되는 자체 로컬 메모리
- 모든 CPU가 공유 시스템 연결로 연결
- 장점: CPU가 로컬 메모리 액세스 할 때 빠르고, 시스템 상호 연결에 대한 경합도 없다<br>
-> 따라서, 프로세서 추가될수록 확장 효과적
- 단점: CPU가 시스템 상호 연결로 원격 메모리에 액세스해야 할 때 지연 시간이 증가해 성능 저하가 발생할 수 있다<br>
+예시) 1번 Processor가 할 일이 3번 Node의 Memory에 있는 경우? 
1번 Node의 Processor가 3번 Node의 Memory에 해당 데이터를 요청 -> 해당 Memory는 Bus를 통해 값을 Processor에 전달

**블레이드 서버**
- 다수의 처리기 보드, 입출력 보드, 네트워킹 보드들이 하나의 chassis안에 장착되는 형태
- 다중 처리기 시스템과 차이점: 각 블레이드-처리기 보드는 독립적으로 부팅가능, 자신의 운영체제 수행
- 자체가 다중 처리기이기도 함 -> 여러 독립적인 다중 처리기 시스템으로 구성된다고 본다

### 1.3.3 클러스터형 시스템 Clustered
- 둘 이상의 독자적 컴퓨터(노드)를 네트워크로 연결해 하나의 시스템처럼 동작하도록 구성
- 각 노드는 다중 코어 시스템
- 각 노드는 독립적인 CPU, 메모리, 디스크를 가진다
- 저장장치를 공유할 수도 있고, 공유하지 않을 수도 있다
- 높은 가용성: 클러스터 내 하나 이상의 컴퓨터 시스템이 고장나도 서비스 계속됨<br>
각 노드는 하나 이상의 다른 노드를 감시 -> 감시받던 노드가 고장나면 감시하던 노드가 고장 난 노드의 저장장치에 대한 소유권을 넘겨받고 그 노드에서 실행 중이던 응용 프로그램을 다시 시작
- 결함허용 시스템: 장애를 감지 및 진단해 단일 구성요소에 오류가 발생해도 계속 작동
- 프로세서 간 통신: 네트워크 통해
- 구성 종류: 비대칭형 or 대칭형

**비대칭형 클러스터링**
- 다른 컴퓨터들이 응용 프로그램 실행하는 동안 한 컴퓨터는 긴급 대기 모드 상태 유지
- 긴급 대기 모드 호스트: 활성 서버들을 감시
- 서버 고장시 긴급 대기 모드 호스트가 활성 서버가 된다

**대칭형 클러스터링**
- 둘 이상의 호스트들이 응용 프로그램 실행하고 서로 감시
- 가용한 하드웨어 모두 사용 -> 효율적


한 클러스터: 네트워크로 연결된 다수의 컴퓨터 시스템으로 구성 -> 클러스터 내 모든 컴퓨터에서 응용을 병렬 수행 (병렬화 기법) -> 고성능 계산 환경 제공

**병렬화**
- 프로그램을 컴퓨터의 개별 코어에서 혹은 클러스터의 각 컴퓨터에서 수행되는 분리된 요소로 나누는 작업
- 각 계산 노드가 문제 일부 해결한 후 모든 노드의 결과를 결합해 최종 해답 얻음

**병렬 클러스터**
- 여러 호스트가 공유 저장장치상의 동일한 데이터에 접근할 수 있게 한다
- 분산 잠금 관리자(DLM): 데이터에 대한 공유 접근 제공을 위해, 시스템은 접근간 충돌이 발생하지 않는 것을 보장하고자 접근 제어와 잠금 기법 제공

## 1.4 운영체제의 작동
- 컴퓨터 실행시 실행되는 초기 프로그램(부트스트랩 프로그램)은 컴퓨터 하드웨어 내에 펌웨어로 저장되고, 시스템의 모든 측면을 초기화 
- 부트스트랩 프로그램이 운영체제 커널을 찾아 메모리에 적재 
- 커널이 적재 및 실행되면 시스템과 사용자에게 서비스를 제공할 수 있다 
- 시스템 데몬은 커널이 처리하지 않는 일부 기능을 수행하기 위해 설계된 백그라운드 프로세스이다. 시스템이 부팅될 때 메모리에 로드되며, 커널이 실행되는 동안(즉, 시스템이 켜져 있는 동안) 계속 동작하면서 필요한 서비스를 제공 <br> ex) Linux에서 `systemd`는 첫 번째 시스템 프로그램으로 다른 많은 데몬을 시작한다
- 이렇게 시스템이 완전이 부팅되면 시스템은 이벤트가 발생할 때까지 기다린다.

**데몬(Daemon)**
- 백그라운드에서 실행되는 프로세스
- 사용자가 직접 실행하지 않아도 시스템 부팅 과정에서 자동으로 시작되어 특정 작업을 지속적으로 수행
- 시스템 데몬은 커널 내부의 작업이 아니라 커널 외부에서 실행되는 백그라운드 서비스
- 로그 관리 데몬(syslogd), 스케줄러 데몬(cron) 등

**인터럽트**
- 이벤트
- 트랩(예외): 오류 or 시스템 콜 연산 실행으로 요청되어 발생하는 소프트웨어 생성 인터럽트

### 1.4.1 다중 프로그래밍(multiprogramming)과 다중 태스킹(multitasking)

**multiprogramming**
- CPU가 항상 한 개는 실행할 수 있도록 프로그램 구성 -> CPU 이용률 높임
- 프로세스: 실행중인 프로그램

운영체제는 여러 프로세스를 동시에 메모리에 유지하고, 이 중 하나를 선택해 실행한다. 다중 프로그래밍 되지 않은 시스템은 CPU가 유휴 상태일 수 있다.

다중 프로그램 시스템에서 운영체제는 해당 프로세스가 대기해야 하는 경우 다른 프로세스로 전환한다. CPU는 유휴 상태가 아니다.

**multitasking**
- CPU는 여러 프로세스를 전환하며 실행하지만 전환이 자주 발생해 사용자에게 빠른 응답 시간을 제공한다
- 대화식 입력이 진행되는 동안 CPU를 쉬게하지 않고, 운영체제는 CPU를 다른 사용자의 프로그램으로 신속히 전환
- 응답시간 보장 방법: 가상 메모리<br>
-> 프로그램이 물리 메모리의 크기보다 더 커도 된다

### 1.4.2 이중모드와 다중모드 운용
운영체제와 사용자는 컴퓨터 시스템의 하드웨어 및 소프트웨어 자원을 공유 -> 운영체제는 잘못된 프로그램으로 인해 다른 프로그램이나 운영체제 자체가 잘못 수행될 수 없도록 보장해야 한다 -> 운영체제 코드 실행과 사용자 정의 코드 실행을 구분해야 한다 -> 실행 모드 차별화

- 사용자 모드
- 커널 모드 (=수퍼바이저 모드, 시스템 모드, 특권 모드)

**mode bit** 
- 현재 모드 나타내기 위해 컴퓨터 하드웨어에 존재
- 커널모드(0), 사용자 모드(1)

시스템 부트 시, 하드웨어는 커널 모드에서 시작 -> 운영체제가 적재됨 -> 사용자 모드에서 사용자 프로세스가 시작 -> 트랩이나 인터럽트 발생시 하드웨어는 사용자 모드에서 커널모드로 전환

**특권 명령**
- 악영향 끼칠 수 있는 일부 명령을 특권 명령으로 지정
- 커널 모드에서만 수행되도록 허용

**시스템 콜**
- 운영체제에 의해 수행될 동작을 사용자 프로세스가 요청할 수 있게 한다
- 인터럽트 벡터의 특정 위치로 트랩을 거는 형태 
- 소프트웨어 인터럽트로 취급
- 시스템 콜 수행시, 제어가 인터럽트 벡터 통해 운영체제 내 서비스 루틴으로 전달 -> mode bit가 커널 모드로 설정 -> 커널은 인터럽트 발생시킨 명령 검사해 어떤 시스템 콜이 발생했는지 결정

**하드웨어 보호 기능**
- mode 규칙 위반하는 오류가 하드웨어에 의해 탐지
- 오류는 운영체제가 처리: 하드웨어가 운영체제로 트랩 발생시킴 -> 트랩은 인터럽트 벡터 통해 제어를 운영체제에 넘김
- 오류 발생할 때마다 운영체제는 비정상적으로 프로그램 종료시킴<br>
오류 메시지 주어지고 프로그램 메모리가 덤프되어 파일에 기록된다

### 1.4.3 타이머
**목적**
- 운영체제가 CPU에 대한 제어를 유지하도록 보장
- 제어가 운영체제로 복귀하지 않는 경우가 없도록 방지

지정된 시간 후 컴퓨터를 인터럽트 하도록 설정 가능<br>
타이머 값 변경 명령은 특권 명령<br>
사용자에게 제어 양도 전, 운영체제는 인터럽트를 할 수 있도록 타이머가 설정됐는지 확인한다